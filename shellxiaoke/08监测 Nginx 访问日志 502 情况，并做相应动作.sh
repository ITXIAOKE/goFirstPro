#!/bin/bash
#场景：
#1.访问日志文件的路径：/data/log/access.log
#2.脚本死循环，每10秒检测一次，10秒的日志条数为300条，出现502的比例不低于10%（30条）则需要重启php-fpm服务
#3.重启命令为：/etc/init.d/php-fpm restart
###########################################################
#监测Nginx访问日志502情况，并做相应动作
###########################################################
log=/data/log/access.log
N=30 #设定阈值
while :; do
  #查看访问日志的最新300条，并统计502的次数
  err=$(tail -n 300 $log | grep -c '502" ')
  if [ $err -ge $N ]; then
    /etc/init.d/php-fpm restart 2>/dev/null
    #设定60s延迟防止脚本bug导致无限重启php-fpm服务
    sleep 60
  fi
  sleep 10
done


#文件描述符我们常见的就是系统预留的0，1和2这三个，他们的意义分别有如下对应关系：
#
#0 —— stdin（标准输入）
#1 —— stdout （标准输出）
#2 —— stderr （标准错误）



#重定向操作符号有两个>和>>。尽管这两个操作符都可以将重定向到文件，但是前者会先清空文件，再写入内容；
#后者会将内容追加到现有文件的尾部。（对了，重定向的操作制定的文件如果原来不存在的话，重定向的操作会主动创建这个文件名的文件的）

#你可以将stderr单独定向到一个文件，将stdout重定向到另一个文件：cmd 2>stderr.txt 1>stdout.txt
# 也可以利用下面的方法，将stderr转换成stdout，使得stderr和stdout都被重新定向到同一个文件中：cmd> output.txt 2>&1
#或者采用这个方法（这个经常用到，我个人比较喜欢用这个，
# 少写几个字符(*^__^*) ）cmd &> output.txt  cmd >& output.txt  # 两个表达式效果一样哒~


#/dev/null是一个特殊的设备文件，这个文件接收到的任何数据都会被丢弃。因此，null这个设备通常也被成为位桶（bit bucket）或黑洞。


